// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: composite.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const getOrCreateDirectConversation = `-- name: GetOrCreateDirectConversation :one
WITH existing_conv AS (
  SELECT c.conversations_id
  FROM "Conversations" c
  INNER JOIN "ConversationParticipants" cp1 ON c.conversations_id = cp1.conversation_id
  INNER JOIN "ConversationParticipants" cp2 ON c.conversations_id = cp2.conversation_id
  WHERE cp1.user_id = $1 
    AND cp2.user_id = $2
    AND cp1.user_id != cp2.user_id
  GROUP BY c.conversations_id
  HAVING COUNT(DISTINCT cp1.user_id) = 2
  LIMIT 1
),
new_conv AS (
  INSERT INTO "Conversations" DEFAULT VALUES
  RETURNING conversations_id
),
conv_to_use AS (
  SELECT conversations_id FROM existing_conv
  UNION ALL
  SELECT conversations_id FROM new_conv
  LIMIT 1
),
participant1 AS (
  INSERT INTO "ConversationParticipants" (conversation_id, user_id)
  SELECT conversations_id, $1 FROM conv_to_use
  ON CONFLICT (conversation_id, user_id) DO NOTHING
),
participant2 AS (
  INSERT INTO "ConversationParticipants" (conversation_id, user_id)
  SELECT conversations_id, $2 FROM conv_to_use
  ON CONFLICT (conversation_id, user_id) DO NOTHING
)
SELECT conversations_id FROM conv_to_use
`

type GetOrCreateDirectConversationParams struct {
	UserID   int64 `json:"user_id"`
	UserID_2 int64 `json:"user_id_2"`
}

func (q *Queries) GetOrCreateDirectConversation(ctx context.Context, arg GetOrCreateDirectConversationParams) (int64, error) {
	row := q.db.QueryRow(ctx, getOrCreateDirectConversation, arg.UserID, arg.UserID_2)
	var conversations_id int64
	err := row.Scan(&conversations_id)
	return conversations_id, err
}

const getUserConversationsWithLastMessage = `-- name: GetUserConversationsWithLastMessage :many
SELECT 
  c.conversations_id,
  c.updated_at,
  u.id as other_user_id,
  u.username as other_user_username,
  u.profile_picture_url as other_user_avatar,
  u.is_online as other_user_online,
  u.last_seen_at as other_user_last_seen,
  latest_msg.encrypted_content as last_message_content,
  latest_msg.sent_at as last_message_time,
  latest_msg.sender_id as last_message_sender_id,
  COUNT(unread_msg.messages_id) as unread_count
FROM "Conversations" c
INNER JOIN "ConversationParticipants" cp ON c.conversations_id = cp.conversation_id
INNER JOIN "ConversationParticipants" other_cp ON c.conversations_id = other_cp.conversation_id AND other_cp.user_id != cp.user_id
INNER JOIN "Users" u ON other_cp.user_id = u.id
LEFT JOIN LATERAL (
  SELECT messages_id, encrypted_content, sent_at, sender_id
  FROM "Messages"
  WHERE conversation_id = c.conversations_id
  ORDER BY sent_at DESC
  LIMIT 1
) latest_msg ON true
LEFT JOIN "Messages" unread_msg ON unread_msg.conversation_id = c.conversations_id 
  AND unread_msg.sent_at > COALESCE(cp.last_read_at, '1970-01-01'::timestamp)
  AND unread_msg.sender_id != cp.user_id
WHERE cp.user_id = $1
GROUP BY 
  c.conversations_id, 
  c.updated_at,
  u.id,
  u.username,
  u.profile_picture_url,
  u.is_online,
  u.last_seen_at,
  latest_msg.encrypted_content,
  latest_msg.sent_at,
  latest_msg.sender_id
ORDER BY COALESCE(latest_msg.sent_at, c.created_at) DESC
LIMIT $2 OFFSET $3
`

type GetUserConversationsWithLastMessageParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetUserConversationsWithLastMessageRow struct {
	ConversationsID     int64              `json:"conversations_id"`
	UpdatedAt           time.Time          `json:"updated_at"`
	OtherUserID         int64              `json:"other_user_id"`
	OtherUserUsername   string             `json:"other_user_username"`
	OtherUserAvatar     pgtype.Text        `json:"other_user_avatar"`
	OtherUserOnline     bool               `json:"other_user_online"`
	OtherUserLastSeen   pgtype.Timestamptz `json:"other_user_last_seen"`
	LastMessageContent  string             `json:"last_message_content"`
	LastMessageTime     time.Time          `json:"last_message_time"`
	LastMessageSenderID int64              `json:"last_message_sender_id"`
	UnreadCount         int64              `json:"unread_count"`
}

func (q *Queries) GetUserConversationsWithLastMessage(ctx context.Context, arg GetUserConversationsWithLastMessageParams) ([]GetUserConversationsWithLastMessageRow, error) {
	rows, err := q.db.Query(ctx, getUserConversationsWithLastMessage, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserConversationsWithLastMessageRow{}
	for rows.Next() {
		var i GetUserConversationsWithLastMessageRow
		if err := rows.Scan(
			&i.ConversationsID,
			&i.UpdatedAt,
			&i.OtherUserID,
			&i.OtherUserUsername,
			&i.OtherUserAvatar,
			&i.OtherUserOnline,
			&i.OtherUserLastSeen,
			&i.LastMessageContent,
			&i.LastMessageTime,
			&i.LastMessageSenderID,
			&i.UnreadCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
