// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: message.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMessage = `-- name: CreateMessage :one
INSERT INTO "Messages" (
  conversation_id,
  sender_id,
  encrypted_content,
  client_message_id
) VALUES (
  $1, $2, $3, $4
)
RETURNING messages_id, conversation_id, sender_id, encrypted_content, client_message_id, sent_at
`

type CreateMessageParams struct {
	ConversationID   int64  `json:"conversation_id"`
	SenderID         int64  `json:"sender_id"`
	EncryptedContent string `json:"encrypted_content"`
	ClientMessageID  string `json:"client_message_id"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, createMessage,
		arg.ConversationID,
		arg.SenderID,
		arg.EncryptedContent,
		arg.ClientMessageID,
	)
	var i Message
	err := row.Scan(
		&i.MessagesID,
		&i.ConversationID,
		&i.SenderID,
		&i.EncryptedContent,
		&i.ClientMessageID,
		&i.SentAt,
	)
	return i, err
}

const deleteMessage = `-- name: DeleteMessage :exec
DELETE FROM "Messages"
WHERE messages_id = $1
`

func (q *Queries) DeleteMessage(ctx context.Context, messagesID int64) error {
	_, err := q.db.Exec(ctx, deleteMessage, messagesID)
	return err
}

const getConversationMessages = `-- name: GetConversationMessages :many
SELECT 
  m.messages_id,
  m.conversation_id,
  m.sender_id,
  m.encrypted_content,
  m.sent_at,
  u.username as sender_username,
  u.profile_picture_url as sender_avatar
FROM "Messages" m
INNER JOIN "Users" u ON m.sender_id = u.id
WHERE m.conversation_id = $1
ORDER BY m.sent_at DESC
LIMIT $2 OFFSET $3
`

type GetConversationMessagesParams struct {
	ConversationID int64 `json:"conversation_id"`
	Limit          int32 `json:"limit"`
	Offset         int32 `json:"offset"`
}

type GetConversationMessagesRow struct {
	MessagesID       int64       `json:"messages_id"`
	ConversationID   int64       `json:"conversation_id"`
	SenderID         int64       `json:"sender_id"`
	EncryptedContent string      `json:"encrypted_content"`
	SentAt           time.Time   `json:"sent_at"`
	SenderUsername   string      `json:"sender_username"`
	SenderAvatar     pgtype.Text `json:"sender_avatar"`
}

func (q *Queries) GetConversationMessages(ctx context.Context, arg GetConversationMessagesParams) ([]GetConversationMessagesRow, error) {
	rows, err := q.db.Query(ctx, getConversationMessages, arg.ConversationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetConversationMessagesRow{}
	for rows.Next() {
		var i GetConversationMessagesRow
		if err := rows.Scan(
			&i.MessagesID,
			&i.ConversationID,
			&i.SenderID,
			&i.EncryptedContent,
			&i.SentAt,
			&i.SenderUsername,
			&i.SenderAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestMessage = `-- name: GetLatestMessage :one
SELECT 
  m.messages_id,
  m.encrypted_content,
  m.sent_at,
  u.username as sender_username
FROM "Messages" m
INNER JOIN "Users" u ON m.sender_id = u.id
WHERE m.conversation_id = $1
ORDER BY m.sent_at DESC
LIMIT 1
`

type GetLatestMessageRow struct {
	MessagesID       int64     `json:"messages_id"`
	EncryptedContent string    `json:"encrypted_content"`
	SentAt           time.Time `json:"sent_at"`
	SenderUsername   string    `json:"sender_username"`
}

func (q *Queries) GetLatestMessage(ctx context.Context, conversationID int64) (GetLatestMessageRow, error) {
	row := q.db.QueryRow(ctx, getLatestMessage, conversationID)
	var i GetLatestMessageRow
	err := row.Scan(
		&i.MessagesID,
		&i.EncryptedContent,
		&i.SentAt,
		&i.SenderUsername,
	)
	return i, err
}

const getMessageByClientID = `-- name: GetMessageByClientID :one
SELECT messages_id, conversation_id, sender_id, encrypted_content, client_message_id, sent_at FROM "Messages"
WHERE client_message_id = $1
`

func (q *Queries) GetMessageByClientID(ctx context.Context, clientMessageID string) (Message, error) {
	row := q.db.QueryRow(ctx, getMessageByClientID, clientMessageID)
	var i Message
	err := row.Scan(
		&i.MessagesID,
		&i.ConversationID,
		&i.SenderID,
		&i.EncryptedContent,
		&i.ClientMessageID,
		&i.SentAt,
	)
	return i, err
}

const getMessageByID = `-- name: GetMessageByID :one
SELECT 
  m.messages_id, m.conversation_id, m.sender_id, m.encrypted_content, m.client_message_id, m.sent_at,
  u.username as sender_username,
  u.profile_picture_url as sender_avatar
FROM "Messages" m
INNER JOIN "Users" u ON m.sender_id = u.id
WHERE m.messages_id = $1
`

type GetMessageByIDRow struct {
	MessagesID       int64       `json:"messages_id"`
	ConversationID   int64       `json:"conversation_id"`
	SenderID         int64       `json:"sender_id"`
	EncryptedContent string      `json:"encrypted_content"`
	ClientMessageID  string      `json:"client_message_id"`
	SentAt           time.Time   `json:"sent_at"`
	SenderUsername   string      `json:"sender_username"`
	SenderAvatar     pgtype.Text `json:"sender_avatar"`
}

func (q *Queries) GetMessageByID(ctx context.Context, messagesID int64) (GetMessageByIDRow, error) {
	row := q.db.QueryRow(ctx, getMessageByID, messagesID)
	var i GetMessageByIDRow
	err := row.Scan(
		&i.MessagesID,
		&i.ConversationID,
		&i.SenderID,
		&i.EncryptedContent,
		&i.ClientMessageID,
		&i.SentAt,
		&i.SenderUsername,
		&i.SenderAvatar,
	)
	return i, err
}

const getMessageCount = `-- name: GetMessageCount :one
SELECT COUNT(*) as total_messages
FROM "Messages"
WHERE conversation_id = $1
`

func (q *Queries) GetMessageCount(ctx context.Context, conversationID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getMessageCount, conversationID)
	var total_messages int64
	err := row.Scan(&total_messages)
	return total_messages, err
}

const getMessagesBefore = `-- name: GetMessagesBefore :many
SELECT 
  m.messages_id,
  m.conversation_id,
  m.sender_id,
  m.encrypted_content,
  m.sent_at,
  u.username as sender_username,
  u.profile_picture_url as sender_avatar
FROM "Messages" m
INNER JOIN "Users" u ON m.sender_id = u.id
WHERE m.conversation_id = $1 
  AND m.sent_at < $2
ORDER BY m.sent_at DESC
LIMIT $3
`

type GetMessagesBeforeParams struct {
	ConversationID int64     `json:"conversation_id"`
	SentAt         time.Time `json:"sent_at"`
	Limit          int32     `json:"limit"`
}

type GetMessagesBeforeRow struct {
	MessagesID       int64       `json:"messages_id"`
	ConversationID   int64       `json:"conversation_id"`
	SenderID         int64       `json:"sender_id"`
	EncryptedContent string      `json:"encrypted_content"`
	SentAt           time.Time   `json:"sent_at"`
	SenderUsername   string      `json:"sender_username"`
	SenderAvatar     pgtype.Text `json:"sender_avatar"`
}

func (q *Queries) GetMessagesBefore(ctx context.Context, arg GetMessagesBeforeParams) ([]GetMessagesBeforeRow, error) {
	rows, err := q.db.Query(ctx, getMessagesBefore, arg.ConversationID, arg.SentAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMessagesBeforeRow{}
	for rows.Next() {
		var i GetMessagesBeforeRow
		if err := rows.Scan(
			&i.MessagesID,
			&i.ConversationID,
			&i.SenderID,
			&i.EncryptedContent,
			&i.SentAt,
			&i.SenderUsername,
			&i.SenderAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesSince = `-- name: GetMessagesSince :many
SELECT 
  m.messages_id,
  m.conversation_id,
  m.sender_id,
  m.encrypted_content,
  m.sent_at,
  u.username as sender_username,
  u.profile_picture_url as sender_avatar
FROM "Messages" m
INNER JOIN "Users" u ON m.sender_id = u.id
WHERE m.conversation_id = $1 
  AND m.sent_at > $2
ORDER BY m.sent_at ASC
`

type GetMessagesSinceParams struct {
	ConversationID int64     `json:"conversation_id"`
	SentAt         time.Time `json:"sent_at"`
}

type GetMessagesSinceRow struct {
	MessagesID       int64       `json:"messages_id"`
	ConversationID   int64       `json:"conversation_id"`
	SenderID         int64       `json:"sender_id"`
	EncryptedContent string      `json:"encrypted_content"`
	SentAt           time.Time   `json:"sent_at"`
	SenderUsername   string      `json:"sender_username"`
	SenderAvatar     pgtype.Text `json:"sender_avatar"`
}

func (q *Queries) GetMessagesSince(ctx context.Context, arg GetMessagesSinceParams) ([]GetMessagesSinceRow, error) {
	rows, err := q.db.Query(ctx, getMessagesSince, arg.ConversationID, arg.SentAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMessagesSinceRow{}
	for rows.Next() {
		var i GetMessagesSinceRow
		if err := rows.Scan(
			&i.MessagesID,
			&i.ConversationID,
			&i.SenderID,
			&i.EncryptedContent,
			&i.SentAt,
			&i.SenderUsername,
			&i.SenderAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMessages = `-- name: SearchMessages :many
SELECT 
  m.messages_id,
  m.conversation_id,
  m.sender_id,
  m.encrypted_content,
  m.sent_at,
  u.username as sender_username
FROM "Messages" m
INNER JOIN "Users" u ON m.sender_id = u.id
WHERE m.conversation_id = $1
  AND m.encrypted_content ILIKE $2
ORDER BY m.sent_at DESC
LIMIT $3
`

type SearchMessagesParams struct {
	ConversationID   int64  `json:"conversation_id"`
	EncryptedContent string `json:"encrypted_content"`
	Limit            int32  `json:"limit"`
}

type SearchMessagesRow struct {
	MessagesID       int64     `json:"messages_id"`
	ConversationID   int64     `json:"conversation_id"`
	SenderID         int64     `json:"sender_id"`
	EncryptedContent string    `json:"encrypted_content"`
	SentAt           time.Time `json:"sent_at"`
	SenderUsername   string    `json:"sender_username"`
}

func (q *Queries) SearchMessages(ctx context.Context, arg SearchMessagesParams) ([]SearchMessagesRow, error) {
	rows, err := q.db.Query(ctx, searchMessages, arg.ConversationID, arg.EncryptedContent, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchMessagesRow{}
	for rows.Next() {
		var i SearchMessagesRow
		if err := rows.Scan(
			&i.MessagesID,
			&i.ConversationID,
			&i.SenderID,
			&i.EncryptedContent,
			&i.SentAt,
			&i.SenderUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
