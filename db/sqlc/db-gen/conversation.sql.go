// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: conversation.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createConversation = `-- name: CreateConversation :one
INSERT INTO "Conversations" DEFAULT VALUES
RETURNING conversations_id, created_at, updated_at
`

func (q *Queries) CreateConversation(ctx context.Context) (Conversation, error) {
	row := q.db.QueryRow(ctx, createConversation)
	var i Conversation
	err := row.Scan(&i.ConversationsID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const findDirectConversation = `-- name: FindDirectConversation :one
SELECT cp1.conversation_id
FROM "ConversationParticipants" cp1
INNER JOIN "ConversationParticipants" cp2 
  ON cp1.conversation_id = cp2.conversation_id
WHERE cp1.user_id = $1 
  AND cp2.user_id = $2
  AND cp1.user_id != cp2.user_id
LIMIT 1
`

type FindDirectConversationParams struct {
	UserID   int64 `json:"user_id"`
	UserID_2 int64 `json:"user_id_2"`
}

func (q *Queries) FindDirectConversation(ctx context.Context, arg FindDirectConversationParams) (int64, error) {
	row := q.db.QueryRow(ctx, findDirectConversation, arg.UserID, arg.UserID_2)
	var conversation_id int64
	err := row.Scan(&conversation_id)
	return conversation_id, err
}

const getAllConversations = `-- name: GetAllConversations :many
SELECT conversations_id, created_at, updated_at FROM "Conversations"
ORDER BY updated_at DESC
LIMIT $1 OFFSET $2
`

type GetAllConversationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllConversations(ctx context.Context, arg GetAllConversationsParams) ([]Conversation, error) {
	rows, err := q.db.Query(ctx, getAllConversations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Conversation{}
	for rows.Next() {
		var i Conversation
		if err := rows.Scan(&i.ConversationsID, &i.CreatedAt, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConversationByID = `-- name: GetConversationByID :one
SELECT conversations_id, created_at, updated_at FROM "Conversations"
WHERE conversations_id = $1
`

func (q *Queries) GetConversationByID(ctx context.Context, conversationsID int64) (Conversation, error) {
	row := q.db.QueryRow(ctx, getConversationByID, conversationsID)
	var i Conversation
	err := row.Scan(&i.ConversationsID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const getConversationWithParticipants = `-- name: GetConversationWithParticipants :many
SELECT 
  c.conversations_id,
  c.created_at,
  c.updated_at,
  u.id as participant_id,
  u.username as participant_username,
  u.profile_picture_url as participant_avatar,
  u.is_online as participant_online,
  cp.last_read_at,
  cp.joined_at
FROM "Conversations" c
INNER JOIN "ConversationParticipants" cp ON c.conversations_id = cp.conversation_id
INNER JOIN "Users" u ON cp.user_id = u.id
WHERE c.conversations_id = $1
`

type GetConversationWithParticipantsRow struct {
	ConversationsID     int64              `json:"conversations_id"`
	CreatedAt           time.Time          `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	ParticipantID       int64              `json:"participant_id"`
	ParticipantUsername string             `json:"participant_username"`
	ParticipantAvatar   pgtype.Text        `json:"participant_avatar"`
	ParticipantOnline   bool               `json:"participant_online"`
	LastReadAt          pgtype.Timestamptz `json:"last_read_at"`
	JoinedAt            time.Time          `json:"joined_at"`
}

func (q *Queries) GetConversationWithParticipants(ctx context.Context, conversationsID int64) ([]GetConversationWithParticipantsRow, error) {
	rows, err := q.db.Query(ctx, getConversationWithParticipants, conversationsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetConversationWithParticipantsRow{}
	for rows.Next() {
		var i GetConversationWithParticipantsRow
		if err := rows.Scan(
			&i.ConversationsID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParticipantID,
			&i.ParticipantUsername,
			&i.ParticipantAvatar,
			&i.ParticipantOnline,
			&i.LastReadAt,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserConversations = `-- name: GetUserConversations :many
SELECT 
  c.conversations_id,
  c.created_at,
  c.updated_at,
  COUNT(CASE WHEN m.sent_at > cp.last_read_at THEN 1 END) as unread_count
FROM "Conversations" c
INNER JOIN "ConversationParticipants" cp ON c.conversations_id = cp.conversation_id
LEFT JOIN "Messages" m ON c.conversations_id = m.conversation_id
WHERE cp.user_id = $1
GROUP BY c.conversations_id, c.created_at, c.updated_at, cp.last_read_at
ORDER BY c.updated_at DESC
LIMIT $2 OFFSET $3
`

type GetUserConversationsParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetUserConversationsRow struct {
	ConversationsID int64     `json:"conversations_id"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	UnreadCount     int64     `json:"unread_count"`
}

func (q *Queries) GetUserConversations(ctx context.Context, arg GetUserConversationsParams) ([]GetUserConversationsRow, error) {
	rows, err := q.db.Query(ctx, getUserConversations, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserConversationsRow{}
	for rows.Next() {
		var i GetUserConversationsRow
		if err := rows.Scan(
			&i.ConversationsID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UnreadCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateConversationTimestamp = `-- name: UpdateConversationTimestamp :exec
UPDATE "Conversations"
SET updated_at = now()
WHERE conversations_id = $1
`

func (q *Queries) UpdateConversationTimestamp(ctx context.Context, conversationsID int64) error {
	_, err := q.db.Exec(ctx, updateConversationTimestamp, conversationsID)
	return err
}
